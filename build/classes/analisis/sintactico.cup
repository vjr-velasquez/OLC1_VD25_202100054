package analisis;

// importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;

import abstracto.Instruccion;
import Simbolo.Tipo;
import Simbolo.tipoDato;

// expresiones
import expresiones.Nativo;
import expresiones.Aritmeticas;
import expresiones.OperadoresAritmeticos;
import expresiones.Relacionales;
import expresiones.OperadoresRelacionales;
import expresiones.Logicas;
import expresiones.OperadoresLogicos;
import expresiones.AccesoVar;
import expresiones.VectorLiteral;
import expresiones.AccesoVector;

// instrucciones
import instrucciones.Print;
import instrucciones.Declaracion;
import instrucciones.AsignacionVar;
import instrucciones.If;
import instrucciones.While;
import instrucciones.For;
import instrucciones.Break;
import instrucciones.Continue;
import instrucciones.Switch;
import instrucciones.CaseSwitch;
import instrucciones.DoWhile;
import instrucciones.AsignacionVector;

import excepciones.Errores;
import excepciones.ControlErrores;


parser code
{:
    public parser(scanner s){
        super(s);
    }

    public void syntax_error(Symbol s){
        String desc = "Error sintáctico. No se esperaba: " + s.value;
        System.out.println(desc + " (línea " + s.left + ", columna " + s.right + ")");
        Errores err = new Errores("SINTACTICO", desc, s.left, s.right);
        ControlErrores.agregarError(err);
    }

    public void unrecovered_syntax_error(Symbol s){
        String desc = "Error sintáctico NO recuperable. No se esperaba: " + s.value;
        System.out.println(desc + " (línea " + s.left + ", columna " + s.right + ")");
        Errores err = new Errores("SINTACTICO", desc, s.left, s.right);
        ControlErrores.agregarError(err);
    }
:}


action code
{:
:}

// ========== TERMINALES ==========

// con valor
terminal String    CADENA, ENTERO, DECIMAL, ID, INT, DOUBLE, STRING, VAR;
terminal Character CHAR;

// sin valor
terminal FINCADENA, PRINT, PAR1, PAR2, MAS, MENOS, UMENOS, DOSPUNTOS;
terminal CORCHIZQ, CORCHDER, COMA;
terminal IGUAL, EQUALS;
terminal TRUE, FALSE, BOOL;
terminal IF, ELSE, LLAVEIZQ, LLAVEDER;
terminal SWITCH, CASE, DEFAULT;
terminal _while, _for, _break, _continue;
terminal DO;    


terminal POR, DIV, MOD, POT;
terminal MENORQ, MAYORQ, MENORIGUAL, MAYORIGUAL, DIFERENTE;
terminal AND, OR, XOR, NOT;

// ========== NO TERMINALES ==========

nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion EXPRESION;
nonterminal Instruccion DECLARACION, ASIGNACION;
nonterminal Tipo TIPOS;
nonterminal Instruccion SIF;
nonterminal Instruccion SWHILE, SFOR, STRANS;
nonterminal Instruccion ASIG_FOR;

nonterminal Instruccion SSWITCH;
nonterminal LinkedList<CaseSwitch> LCASES;
nonterminal CaseSwitch CASEITEM;
nonterminal LinkedList<Instruccion> DFLT_OPT;

nonterminal Instruccion SDO;

// vectores
nonterminal LinkedList<Instruccion> LISTA_EXP;
nonterminal Instruccion VECTOR_LIT;



// ========== PRECEDENCIAS ==========

// lógicos
precedence left OR;
precedence left XOR;
precedence left AND;
precedence right NOT;

// relacionales
precedence left EQUALS, DIFERENTE, MENORQ, MENORIGUAL, MAYORQ, MAYORIGUAL;

// aritméticos
precedence left MAS, MENOS;
precedence left POR, DIV, MOD;
precedence nonassoc POT;

// unario
precedence right UMENOS;

// símbolo inicial
start with INICIO;

// ========== PRODUCCIONES ==========

INICIO ::= INSTRUCCIONES:a   {: RESULT = a; :}
;

INSTRUCCIONES ::=
      INSTRUCCIONES:a INSTRUCCION:b
        {: if (b != null) { a.add(b); } RESULT = a; :}
    | INSTRUCCION:a
        {: RESULT = new LinkedList<>(); if (a != null) RESULT.add(a); :}
;

// Instrucciones de alto nivel
INSTRUCCION ::=
      PRINT PAR1 EXPRESION:a PAR2 FINCADENA
        {: RESULT = new Print(a, aleft, aright); :}
    | DECLARACION:a  {: RESULT = a; :}
    | ASIGNACION:a   {: RESULT = a; :}
    | SIF:a          {: RESULT = a; :}
    | SWHILE:a       {: RESULT = a; :}
    | SFOR:a         {: RESULT = a; :}
    | STRANS:a       {: RESULT = a; :}
    | SSWITCH:a      {: RESULT = a; :}
    | SDO:a          {: RESULT = a; :}

    // asignación a vector: id[exp] = exp;
    | ID:a CORCHIZQ EXPRESION:i CORCHDER IGUAL EXPRESION:v FINCADENA
        {: RESULT = new AsignacionVector(a, i, v, aleft, aright); :}

    // recuperación (para que no te mate el parse)
    | error FINCADENA {: RESULT = null; :}
    | error          {: RESULT = null; :}
;

SDO ::=
    DO
    LLAVEIZQ INSTRUCCIONES:lista LLAVEDER
    _while PAR1 EXPRESION:cond PAR2 FINCADENA
    {:
        RESULT = new DoWhile(cond, lista, condleft, condright);
    :}
;


// ---------- SWITCH / CASE / DEFAULT ----------

SSWITCH ::=
    SWITCH PAR1 EXPRESION:cond PAR2
    LLAVEIZQ LCASES:cases DFLT_OPT:def LLAVEDER
    {:
        RESULT = new Switch(cond, cases, def, condleft, condright);
    :}
;

LCASES ::=
      /* vacío */
        {:
            RESULT = new LinkedList<CaseSwitch>();
        :}
    | LCASES:ls CASEITEM:c
        {:
            ls.add(c);
            RESULT = ls;
        :}
;

CASEITEM ::=
    CASE EXPRESION:exp DOSPUNTOS
    LLAVEIZQ INSTRUCCIONES:lista LLAVEDER
    {:
        RESULT = new CaseSwitch(exp, lista);
    :}
;

DFLT_OPT ::=
      DEFAULT DOSPUNTOS
      LLAVEIZQ INSTRUCCIONES:lista LLAVEDER
        {:
            RESULT = lista;
        :}
    | /* vacío */
        {:
            RESULT = null;
        :}
;


// ---------- WHILE ----------

SWHILE ::=
    _while PAR1 EXPRESION:cond PAR2 LLAVEIZQ INSTRUCCIONES:lista LLAVEDER
    {:
        RESULT = new While(cond, lista, condleft, condright);
    :}
;


// ---------- FOR ----------

ASIG_FOR ::=
    ID:a IGUAL EXPRESION:b
    {:
        RESULT = new AsignacionVar(a, b, aleft, aright);
    :}
;

SFOR ::=
    _for PAR1 ASIG_FOR:ini FINCADENA
         EXPRESION:cond FINCADENA
         ASIG_FOR:act PAR2
         LLAVEIZQ INSTRUCCIONES:lista LLAVEDER
    {:
        RESULT = new For(ini, cond, act, lista, condleft, condright);
    :}
;


// ---------- break / continue ----------

STRANS ::=
      _break:bk FINCADENA
        {:
            RESULT = new Break(bkleft, bkright);
        :}
    | _continue:ct FINCADENA
        {:
            RESULT = new Continue(ctleft, ctright);
        :}
;


// ---------- IF / ELSE ----------

SIF ::=
      IF PAR1 EXPRESION:cond PAR2 LLAVEIZQ INSTRUCCIONES:lista LLAVEDER
        {: RESULT = new If(cond, lista, null, condleft, condright); :}
    | IF PAR1 EXPRESION:cond PAR2 LLAVEIZQ INSTRUCCIONES:lista LLAVEDER
      ELSE LLAVEIZQ INSTRUCCIONES:listaElse LLAVEDER
        {: RESULT = new If(cond, lista, listaElse, condleft, condright); :}
;


// ---------- Declaración de variables ----------

DECLARACION ::=
      VAR ID:b DOSPUNTOS TIPOS:a IGUAL EXPRESION:c FINCADENA
        {: RESULT = new Declaracion(b, c, a, aleft, aright); :}
    | VAR ID:b DOSPUNTOS TIPOS:a FINCADENA
        {: RESULT = new Declaracion(b, null, a, bleft, bright); :}
;


// ---------- Asignación de variables ----------

ASIGNACION ::=
    ID:a IGUAL EXPRESION:b FINCADENA
        {: RESULT = new AsignacionVar(a, b, aleft, aright); :}
;


// ---------- Tipos ----------

TIPOS ::=
      INT    {: RESULT = new Tipo(tipoDato.ENTERO);   :}
    | DOUBLE {: RESULT = new Tipo(tipoDato.DECIMAL);  :}
    | STRING {: RESULT = new Tipo(tipoDato.CADENA);   :}
    | BOOL   {: RESULT = new Tipo(tipoDato.BOOLEANO); :}

    // vectores: tipo[]
    | INT    CORCHIZQ CORCHDER {: RESULT = new Tipo(tipoDato.ENTERO, 1);   :}
    | DOUBLE CORCHIZQ CORCHDER {: RESULT = new Tipo(tipoDato.DECIMAL, 1);  :}
    | STRING CORCHIZQ CORCHDER {: RESULT = new Tipo(tipoDato.CADENA, 1);   :}
    | BOOL   CORCHIZQ CORCHDER {: RESULT = new Tipo(tipoDato.BOOLEANO, 1); :}
;


// ---------- Literales de vector ----------

VECTOR_LIT ::=
      CORCHIZQ:ci CORCHDER:cd
        {:
            RESULT = new VectorLiteral(new LinkedList<Instruccion>(), cileft, cdright);
        :}
    | CORCHIZQ:ci LISTA_EXP:lst CORCHDER:cd
        {:
            RESULT = new VectorLiteral(lst, cileft, cdright);
        :}
;



LISTA_EXP ::=
      LISTA_EXP:ls COMA EXPRESION:e
        {: ls.add(e); RESULT = ls; :}
    | EXPRESION:e
        {: RESULT = new LinkedList<Instruccion>(); RESULT.add(e); :}
;


// ========== EXPRESIONES ==========

EXPRESION ::=
    /* ----- UNARIO ----- */
      MENOS EXPRESION:a
        {: RESULT = new Aritmeticas(OperadoresAritmeticos.NEGACION, a, aleft, aright); :} %prec UMENOS

    /* ----- ARITMÉTICOS ----- */
    | EXPRESION:a MAS   EXPRESION:b
        {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA,  aleft, aright); :}

    | EXPRESION:a MENOS EXPRESION:b
        {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RESTA, aleft, aright); :}

    | EXPRESION:a POR   EXPRESION:b
        {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright); :}

    | EXPRESION:a DIV   EXPRESION:b
        {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.DIVISION, aleft, aright); :}

    | EXPRESION:a MOD   EXPRESION:b
        {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MODULO, aleft, aright); :}

    | EXPRESION:a POT   EXPRESION:b
        {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright); :}

    /* ----- RELACIONALES ----- */

    | EXPRESION:a IGUAL IGUAL EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.EQUALS, aleft, aright); :} %prec EQUALS

    | EXPRESION:a DIFERENTE EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.DIFERENTE, aleft, aright); :}

    | EXPRESION:a MENORQ EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MENORQ, aleft, aright); :}

    | EXPRESION:a MAYORQ EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYORQ, aleft, aright); :}

    | EXPRESION:a MENORIGUAL EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MENORIGUAL, aleft, aright); :}

    | EXPRESION:a MAYORIGUAL EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYORIGUAL, aleft, aright); :}

    /* ----- LÓGICOS ----- */

    | EXPRESION:a AND EXPRESION:b
        {: RESULT = new Logicas(a, b, OperadoresLogicos.AND, aleft, aright); :}

    | EXPRESION:a OR EXPRESION:b
        {: RESULT = new Logicas(a, b, OperadoresLogicos.OR, aleft, aright); :}

    | EXPRESION:a XOR EXPRESION:b
        {: RESULT = new Logicas(a, b, OperadoresLogicos.XOR, aleft, aright); :}

    | NOT EXPRESION:a
        {: RESULT = new Logicas(a, OperadoresLogicos.NOT, aleft, aright); :} %prec NOT

    /* ----- PRIMARIOS ----- */

    | PAR1 EXPRESION:a PAR2
        {: RESULT = a; :}

    // vector literal: [] o [a,b,c]
    | VECTOR_LIT:vec
        {: RESULT = vec; :}

    | ENTERO:a
        {: RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright); :}

    | DECIMAL:a
        {: RESULT = new Nativo(new Double(a), new Tipo(tipoDato.DECIMAL), aleft, aright); :}

    | CHAR:a
        {: RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright); :}

    | CADENA:a
        {: RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright); :}

    | TRUE:a
        {: RESULT = new Nativo(true,  new Tipo(tipoDato.BOOLEANO), aleft, aright ); :}

    | FALSE:a
        {: RESULT = new Nativo(false, new Tipo(tipoDato.BOOLEANO), aleft, aright ); :}

    | ID:a
        {: RESULT = new AccesoVar(a, aleft, aright); :}

    // acceso vector: id[exp]
    | ID:a CORCHIZQ EXPRESION:i CORCHDER
        {: RESULT = new AccesoVector(a, i, aleft, aright); :}
;
